using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq; // Added for .Any() and .ToList()
using System.Threading.Tasks;
using System.Windows.Forms;

namespace ProjectLauncher
{
    public partial class MainForm : Form
    {
        // Process objects for each service
        private Process ngrokProcess, dockerProcess, dotnetProcess, expoProcess;

        // Dictionary to manage the running status of each process by name
        private readonly Dictionary<string, bool> processRunningStatus = new Dictionary<string, bool>
        {
            { "Ngrok", false },
            { "Docker", false },
            { "Dotnet Backend", false },
            { "Expo Frontend", false }
        };

        // UI Controls
        private Button btnNgrok, btnNgrokDashboard, btnDocker, btnDotnet, btnExpo;
        private TextBox outputBox;
        // private Label titleLabel; // Removed: Title label is no longer needed
        private TextBox apiUrlInput;
        private Button btnSaveApiUrl;

        // Paths for backend, frontend, ngrok executable, and .env file
        // NOTE: frontendPath is hardcoded to a user-specific path. Consider making this configurable.
        private readonly string backendPath = Path.GetFullPath(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, @"..\Fitness-App-Backend\FitnessAppBackend"));
        private readonly string frontendPath = Path.GetFullPath(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, @"C:\Users\berat\OneDrive\Documents\Github\INFIT-Fitness-App\Fitness-App-Frontend"));
        private readonly string dockerContainerName = "FitnessAppPostgresql";
        private readonly string ngrokPath = @"C:\Users\berat\Downloads\ngrok-v3-stable-windows-amd64\ngrok.exe";
        private readonly string envFilePath = @"C:\Users\berat\OneDrive\Documents\Github\INFIT-Fitness-App\.env";

        // UI Colors
        private readonly Color borderRunningColor = ColorTranslator.FromHtml("#FF2605"); // Red for running state
        private readonly Color borderDefaultColor = ColorTranslator.FromHtml("#5B5B5B"); // Grey for stopped state
        private readonly Color buttonBackColor = ColorTranslator.FromHtml("#1C1C1C");
        private readonly Color consoleBackColor = ColorTranslator.FromHtml("#1C1C1C");

        /// <summary>
        /// Constructor for the MainForm. Initializes UI components and sets up event handlers.
        /// </summary>
        public MainForm()
        {
            InitializeComponent(); // Auto-generated by WinForms designer (kept minimal here)
            SetupUI();             // Custom UI layout and styling
            WireUpEvents();        // Attaches event handlers to buttons
        }

        /// <summary>
        /// Sets up the custom user interface elements and their initial properties.
        /// </summary>
        private void SetupUI()
        {
            this.Text = "INVICTUS AGENT"; // Changed window title
            this.Width = 280; // Made window narrower
            this.Height = 650; // Made window shorter
            this.BackColor = Color.Black;
            this.FormBorderStyle = FormBorderStyle.FixedSingle; // Prevents resizing
            this.MaximizeBox = false; // Disables maximize button
            this.Icon = new Icon("app_icon.ico"); // Load icon from file

            // Button creation using a helper method for consistent styling
            btnNgrok = CreateButton("Start Ngrok");
            btnNgrokDashboard = CreateButton("Open Ngrok Dashboard");
            btnDocker = CreateButton("Start Docker DB");
            btnDotnet = CreateButton("Start Dotnet Backend");
            btnExpo = CreateButton("Start Expo Frontend");

            // API URL input TextBox configuration
            apiUrlInput = new TextBox
            {
                Width = 180, // Adjusted width for smaller buttons
                ForeColor = Color.White,
                BackColor = Color.FromArgb(70, 70, 70),
                BorderStyle = BorderStyle.FixedSingle,
                Font = new Font("Segoe UI", 10F),
            };

            // Save API URL Button configuration
            btnSaveApiUrl = CreateButton("Save API_URL to .env");
            btnSaveApiUrl.Width = 180; // Consistent width with other buttons
            btnSaveApiUrl.Height = 35; // Consistent height with other buttons

            // Output console TextBox configuration
            outputBox = new TextBox
            {
                Multiline = true, // Allows multiple lines of text
                ScrollBars = ScrollBars.Vertical, // Adds vertical scrollbar if content exceeds height
                ReadOnly = true, // Prevents user from typing in the console
                BackColor = consoleBackColor,
                ForeColor = Color.White,
                BorderStyle = BorderStyle.FixedSingle,
            };

            // Add all created controls to the form
            Controls.AddRange(new Control[] {
                btnNgrok, btnNgrokDashboard, btnDocker, btnDotnet, btnExpo,
                apiUrlInput, btnSaveApiUrl,
                outputBox
            });

            ArrangeControls(); // Positions all controls on the form
        }

        /// <summary>
        /// Helper method to create a consistently styled button.
        /// </summary>
        /// <param name="text">The text to display on the button.</param>
        /// <returns>A new Button instance with predefined styling.</returns>
        private Button CreateButton(string text)
        {
            var btn = new Button
            {
                Text = text,
                Width = 180, // Made buttons smaller
                Height = 35, // Made buttons smaller
                BackColor = buttonBackColor,
                ForeColor = Color.White,
                FlatStyle = FlatStyle.Flat, // Flat appearance
                Font = new Font("Segoe UI", 10F),
                TabStop = false, // Not part of tab order
                Cursor = Cursors.Hand
            };
            btn.FlatAppearance.BorderColor = borderDefaultColor; // Initial border color
            btn.FlatAppearance.BorderSize = 2; // Border thickness
            return btn;
        }

        /// <summary>
        /// Arranges and positions all UI controls on the form.
        /// </summary>
        private void ArrangeControls()
        {
            int marginLeft = 20; // Left margin for all controls
            int currentTop = 20; // Adjusted: Starting Y position from the top of the form
            int spacingY = 10;                       // Vertical space between controls within a group (reduced for smaller window)
            int groupSpacingY = 25;                  // Vertical space between different groups of controls (reduced for smaller window)

            // Ngrok Group
            btnNgrok.Left = (ClientSize.Width - btnNgrok.Width) / 2; // Centered
            btnNgrok.Top = currentTop;
            currentTop = btnNgrok.Bottom + spacingY;

            btnNgrokDashboard.Left = (ClientSize.Width - btnNgrokDashboard.Width) / 2; // Centered
            btnNgrokDashboard.Top = currentTop;
            currentTop = btnNgrokDashboard.Bottom + spacingY;

            apiUrlInput.Left = (ClientSize.Width - apiUrlInput.Width) / 2; // Centered
            apiUrlInput.Top = currentTop;
            currentTop = apiUrlInput.Bottom + spacingY;

            btnSaveApiUrl.Left = (ClientSize.Width - btnSaveApiUrl.Width) / 2; // Centered
            btnSaveApiUrl.Top = currentTop;
            currentTop = btnSaveApiUrl.Bottom + groupSpacingY; // Add group spacing after Ngrok controls

            // Docker Group
            btnDocker.Left = (ClientSize.Width - btnDocker.Width) / 2; // Centered
            btnDocker.Top = currentTop;
            currentTop = btnDocker.Bottom + groupSpacingY; // Add group spacing after Docker controls

            // Backend & Frontend Group
            btnDotnet.Left = (ClientSize.Width - btnDotnet.Width) / 2; // Centered
            btnDotnet.Top = currentTop;
            currentTop = btnDotnet.Bottom + spacingY;

            btnExpo.Left = (ClientSize.Width - btnExpo.Width) / 2; // Centered
            btnExpo.Top = currentTop;
            currentTop = btnExpo.Bottom + groupSpacingY; // Add group spacing after Expo controls

            // Output Console (fills remaining space at the bottom)
            outputBox.Top = currentTop;
            outputBox.Left = marginLeft;
            outputBox.Width = ClientSize.Width - (2 * marginLeft); // Width fills form with margins
            outputBox.Height = ClientSize.Height - outputBox.Top - 20; // Height fills to 20px from bottom
        }

        /// <summary>
        /// Wires up event handlers for all interactive UI elements.
        /// </summary>
        private void WireUpEvents()
        {
            btnNgrok.Click += (s, e) => ToggleNgrok();
            btnNgrokDashboard.Click += (s, e) => OpenNgrokDashboard();
            btnDocker.Click += async (s, e) => await ToggleDocker();
            // Using lambda expressions to pass specific arguments to the generic toggle method
            btnDotnet.Click += (s, e) => ToggleGenericProcess("Dotnet Backend", ref dotnetProcess, "dotnet", "run", backendPath, btnDotnet);
            btnExpo.Click += (s, e) => ToggleGenericProcess("Expo Frontend", ref expoProcess, "cmd.exe", "/c npx expo start", frontendPath, btnExpo);
            btnSaveApiUrl.Click += (s, e) => SaveApiUrlFromInput();
        }

        /// <summary>
        /// Toggles the Ngrok process (starts or stops it).
        /// </summary>
        private void ToggleNgrok()
        {
            string processName = "Ngrok";
            if (!processRunningStatus[processName]) // If Ngrok is not running
            {
                try
                {
                    var startInfo = new ProcessStartInfo
                    {
                        FileName = ngrokPath,
                        Arguments = "http https://localhost:7258", // Arguments for Ngrok
                        UseShellExecute = false, // Required to redirect output
                        CreateNoWindow = true,   // Prevents a new console window from appearing
                        RedirectStandardOutput = true, // Redirects standard output stream
                        RedirectStandardError = true,  // Redirects standard error stream
                    };

                    ngrokProcess = Process.Start(startInfo); // Start the Ngrok process
                    if (ngrokProcess != null)
                    {
                        ngrokProcess.EnableRaisingEvents = true; // Enable Exited event
                        // Attach handlers for output and error data received
                        ngrokProcess.OutputDataReceived += (s, e) => { if (!string.IsNullOrEmpty(e.Data)) AppendOutput($"[{processName}] {e.Data}"); };
                        ngrokProcess.ErrorDataReceived += (s, e) => { if (!string.IsNullOrEmpty(e.Data)) AppendOutput($"[{processName} ERROR] {e.Data}"); };
                        // Attach handler for process exit
                        ngrokProcess.Exited += (s, e) => OnProcessExited(processName, ngrokProcess, btnNgrok);

                        ngrokProcess.BeginOutputReadLine(); // Begin asynchronous read of output
                        ngrokProcess.BeginErrorReadLine();  // Begin asynchronous read of error

                        // Update UI and internal state
                        processRunningStatus[processName] = true;
                        btnNgrok.Text = $"Stop {processName}";
                        SetButtonBorder(btnNgrok, borderRunningColor);
                        AppendOutput($"{processName} started.");
                    }
                    else
                    {
                        AppendOutput($"Failed to start {processName}. Process.Start returned null.");
                    }
                }
                catch (Exception ex)
                {
                    AppendOutput($"Exception starting {processName}: {ex.Message}");
                }
            }
            else // If Ngrok is running, stop it
            {
                StopProcess(ref ngrokProcess, btnNgrok, processName);
            }
        }

        /// <summary>
        /// Opens the Ngrok dashboard in the default web browser.
        /// </summary>
        private void OpenNgrokDashboard()
        {
            try
            {
                Process.Start(new ProcessStartInfo
                {
                    FileName = "https://dashboard.ngrok.com/agents",
                    UseShellExecute = true // Uses the default shell to open the URL
                });
                AppendOutput("Opened Ngrok dashboard in browser.");
            }
            catch (Exception ex)
            {
                AppendOutput($"Failed to open Ngrok dashboard: {ex.Message}");
            }
        }

        /// <summary>
        /// Saves the API URL from the input box to the .env file.
        /// </summary>
        private void SaveApiUrlFromInput()
        {
            string url = apiUrlInput.Text.Trim();
            if (string.IsNullOrEmpty(url))
            {
                AppendOutput("API URL input is empty. Please enter a URL.");
                return;
            }
            try
            {
                UpdateEnvApiUrl(envFilePath, "API_URL", url);
            }
            catch (Exception ex)
            {
                AppendOutput($"Failed to save API URL: {ex.Message}");
            }
        }

        /// <summary>
        /// Updates or adds a key-value pair in a .env file.
        /// </summary>
        /// <param name="filePath">The path to the .env file.</param>
        /// <param name="key">The key to update (e.g., "API_URL").</param>
        /// <param name="url">The value to set for the key.</param>
        private void UpdateEnvApiUrl(string filePath, string key, string url)
        {
            try
            {
                List<string> lines = new List<string>();
                if (File.Exists(filePath))
                {
                    lines = File.ReadAllLines(filePath).ToList(); // Read all lines into a modifiable list
                }

                bool found = false;
                for (int i = 0; i < lines.Count; i++)
                {
                    if (lines[i].StartsWith($"{key}=")) // Check if line starts with the key
                    {
                        lines[i] = $"{key}={url}"; // Update the line
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    lines.Add($"{key}={url}"); // If key not found, add a new line
                }

                File.WriteAllLines(filePath, lines); // Write all lines back to the file
                AppendOutput($"Updated {key} in .env file: {url}");
            }
            catch (Exception ex)
            {
                AppendOutput($"Failed to update .env file: {ex.Message}");
            }
        }

        /// <summary>
        /// Toggles the Docker container (starts or stops it asynchronously).
        /// </summary>
        private async Task ToggleDocker()
        {
            string processName = "Docker";
            if (!processRunningStatus[processName]) // If Docker is not running
            {
                AppendOutput($"Attempting to start Docker container '{dockerContainerName}'...");
                // Run the 'docker start' command asynchronously
                bool started = await RunProcessAsync("docker", $"start {dockerContainerName}");

                if (started)
                {
                    // Give Docker some time to fully initialize and report its status
                    await Task.Delay(2000); // Wait 2 seconds for container to stabilize

                    if (IsDockerRunning(dockerContainerName)) // Verify if the container is actually running
                    {
                        processRunningStatus[processName] = true;
                        SetButtonBorder(btnDocker, borderRunningColor);
                        btnDocker.Text = $"Stop {processName} DB";
                        AppendOutput($"Docker container '{dockerContainerName}' is running.");
                    }
                    else
                    {
                        AppendOutput($"Docker container '{dockerContainerName}' failed to start or is not detected as running after delay.");
                        // Reset UI state if start failed
                        SetButtonBorder(btnDocker, borderDefaultColor);
                        btnDocker.Text = $"Start {processName} DB";
                        processRunningStatus[processName] = false;
                    }
                }
                else
                {
                    AppendOutput($"Failed to execute 'docker start {dockerContainerName}' command.");
                    // Reset UI state if command execution failed
                    SetButtonBorder(btnDocker, borderDefaultColor);
                    btnDocker.Text = $"Start {processName} DB";
                    processRunningStatus[processName] = false;
                }
            }
            else // If Docker is running, stop it
            {
                AppendOutput($"Attempting to stop Docker container '{dockerContainerName}'...");
                // Run the 'docker stop' command asynchronously
                bool stopped = await RunProcessAsync("docker", $"stop {dockerContainerName}");
                if (stopped)
                {
                    processRunningStatus[processName] = false;
                    SetButtonBorder(btnDocker, borderDefaultColor);
                    btnDocker.Text = $"Start {processName} DB";
                    AppendOutput($"Docker container '{dockerContainerName}' stopped.");
                }
                else
                {
                    AppendOutput($"Failed to stop Docker container '{dockerContainerName}'.");
                }
            }
        }

        /// <summary>
        /// Generic method to toggle the state of a given process (start or stop).
        /// </summary>
        /// <param name="name">The friendly name of the process (e.g., "Dotnet Backend").</param>
        /// <param name="proc">A reference to the Process object.</param>
        /// <param name="fileName">The executable file name.</param>
        /// <param name="args">Arguments for the executable.</param>
        /// <param name="workingDir">The working directory for the process.</param>
        /// <param name="btn">The button associated with this process.</param>
        private void ToggleGenericProcess(string name, ref Process proc, string fileName, string args, string workingDir, Button btn)
        {
            if (!processRunningStatus[name]) // If the process is not running
            {
                StartGenericProcess(name, ref proc, fileName, args, workingDir, btn);
            }
            else // If the process is running, stop it
            {
                StopProcess(ref proc, btn, name);
            }
        }

        /// <summary>
        /// Starts a generic process, sets up its event handlers, and updates the UI.
        /// </summary>
        /// <param name="name">The friendly name of the process.</param>
        /// <param name="proc">A reference to the Process object to be assigned.</param>
        /// <param name="fileName">The executable file name.</param>
        /// <param name="args">Arguments for the executable.</param>
        /// <param name="workingDir">The working directory for the process.</param>
        /// <param name="btn">The button associated with this process.</param>
        private void StartGenericProcess(string name, ref Process proc, string fileName, string args, string workingDir, Button btn)
        {
            // Defensive check: if process is already running, do nothing
            if (proc != null && !proc.HasExited)
            {
                AppendOutput($"{name} is already running.");
                return;
            }

            var startInfo = new ProcessStartInfo
            {
                FileName = fileName,
                Arguments = args,
                WorkingDirectory = workingDir,
                RedirectStandardOutput = true, // Enable capturing output
                RedirectStandardError = true,  // Enable capturing errors
                UseShellExecute = false,       // Must be false to redirect streams
                CreateNoWindow = true,         // Do not create a new console window
            };

            var localProc = new Process
            {
                StartInfo = startInfo,
                EnableRaisingEvents = true // Crucial for the Exited event to fire
            };

            // Attach event handlers for output, error, and process exit
            localProc.OutputDataReceived += (s, e) => { if (!string.IsNullOrEmpty(e.Data)) AppendOutput($"[{name}] {e.Data}"); };
            localProc.ErrorDataReceived += (s, e) => { if (!string.IsNullOrEmpty(e.Data)) AppendOutput($"[{name} ERROR] {e.Data}"); };
            localProc.Exited += (s, e) => OnProcessExited(name, localProc, btn);

            try
            {
                localProc.Start(); // Attempt to start the process
                localProc.BeginOutputReadLine(); // Start reading output asynchronously
                localProc.BeginErrorReadLine();  // Start reading errors asynchronously

                AppendOutput($"{name} started.");
                proc = localProc; // Assign the newly started process to the ref parameter
                processRunningStatus[name] = true; // Update internal state
                SetButtonBorder(btn, borderRunningColor); // Update button appearance
                btn.Text = $"Stop {name}"; // Update button text
            }
            catch (Exception ex)
            {
                AppendOutput($"Failed to start {name}: {ex.Message}");
                localProc.Dispose(); // Clean up the process object if it failed to start
                // Reset UI state and internal flag if start fails
                processRunningStatus[name] = false;
                SetButtonBorder(btn, borderDefaultColor);
                btn.Text = $"Start {name}";
            }
        }

        /// <summary>
        /// Stops a running process and cleans up its resources.
        /// </summary>
        /// <param name="proc">A reference to the Process object to be stopped.</param>
        /// <param name="btn">The button associated with this process.</param>
        /// <param name="name">The friendly name of the process.</param>
        private void StopProcess(ref Process proc, Button btn, string name)
        {
            // Check if the process object exists and is currently running
            if (proc != null && !proc.HasExited)
            {
                try
                {
                    // Kill the process and its entire tree.
                    // Process.Kill(true) is available in .NET 5+ and is recommended for killing child processes.
                    // For older .NET versions, you might need to enumerate child processes or use 'taskkill'.
                    proc.Kill();
                    proc.WaitForExit(5000); // Wait up to 5 seconds for the process to terminate gracefully

                    proc.Dispose(); // Dispose the process object to release resources
                    proc = null;    // Clear the reference to the process object

                    // Update UI and internal state
                    AppendOutput($"{name} stopped.");
                    processRunningStatus[name] = false;
                    SetButtonBorder(btn, borderDefaultColor);
                    btn.Text = $"Start {name}";
                }
                catch (InvalidOperationException)
                {
                    // This can occur if the process has already exited or is in an invalid state when Kill is called.
                    AppendOutput($"Warning: Attempted to stop {name}, but it was already exiting or in an invalid state.");
                }
                catch (Exception ex)
                {
                    AppendOutput($"Failed to stop {name}: {ex.Message}");
                }
            }
            else
            {
                // If the process was not running or already exited, just ensure UI is consistent
                AppendOutput($"{name} was not running or already exited.");
                processRunningStatus[name] = false;
                SetButtonBorder(btn, borderDefaultColor);
                btn.Text = $"Start {name}";
            }
        }

        /// <summary>
        /// Centralized event handler for when any monitored process exits.
        /// Ensures UI and internal state are updated on the UI thread.
        /// </summary>
        /// <param name="name">The friendly name of the exited process.</param>
        /// <param name="exitedProcess">The Process object that exited.</param>
        /// <param name="btn">The button associated with the exited process.</param>
        private void OnProcessExited(string name, Process exitedProcess, Button btn)
        {
            // Ensure UI updates are performed on the UI thread
            if (InvokeRequired)
            {
                Invoke(new Action(() => OnProcessExited(name, exitedProcess, btn)));
                return;
            }

            AppendOutput($"{name} exited with code {exitedProcess.ExitCode}.");

            // Update the running status in the dictionary
            processRunningStatus[name] = false;

            // Reset button appearance and text
            SetButtonBorder(btn, borderDefaultColor);
            btn.Text = $"Start {name}";

            // Dispose the process object if it hasn't been disposed yet (e.g., if it crashed)
            if (exitedProcess != null && !exitedProcess.HasExited)
            {
                exitedProcess.Dispose();
            }
        }

        /// <summary>
        /// Sets the border color of a given button, ensuring thread safety.
        /// </summary>
        /// <param name="btn">The button to modify.</param>
        /// <param name="color">The new border color.</param>
        private void SetButtonBorder(Button btn, Color color)
        {
            // Ensure UI updates are performed on the UI thread
            if (btn.InvokeRequired)
                btn.Invoke(new Action(() => btn.FlatAppearance.BorderColor = color));
            else
                btn.FlatAppearance.BorderColor = color;
        }

        /// <summary>
        /// Appends a line of text to the output console, ensuring thread safety and auto-scrolling.
        /// </summary>
        /// <param name="text">The text to append.</param>
        private void AppendOutput(string text)
        {
            // Ensure UI updates are performed on the UI thread
            if (InvokeRequired)
                Invoke(new Action(() => AppendOutput(text)));
            else
            {
                outputBox.AppendText(text + Environment.NewLine);
                // Auto-scroll to the bottom of the text box
                outputBox.SelectionStart = outputBox.Text.Length;
                outputBox.ScrollToCaret();
            }
        }

        /// <summary>
        /// Checks if a specific Docker container is currently running.
        /// </summary>
        /// <param name="containerName">The name of the Docker container.</param>
        /// <returns>True if the container is running, false otherwise.</returns>
        private bool IsDockerRunning(string containerName)
        {
            try
            {
                var psi = new ProcessStartInfo
                {
                    FileName = "docker",
                    Arguments = $"ps -q -f name={containerName}", // -q for quiet (only IDs), -f for filter by name
                    RedirectStandardOutput = true, // Capture output
                    UseShellExecute = false,       // Required to redirect output
                    CreateNoWindow = true          // Do not show a console window
                };

                using var process = Process.Start(psi); // Start the docker command
                string output = process.StandardOutput.ReadToEnd(); // Read all output
                process.WaitForExit(); // Wait for the command to complete
                return !string.IsNullOrEmpty(output.Trim()); // If output is not empty, container ID was found (meaning it's running)
            }
            catch (Exception ex)
            {
                AppendOutput($"Error checking Docker status: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// Runs an external process asynchronously and returns true if it exited successfully (exit code 0).
        /// Captures and logs its output and error streams.
        /// </summary>
        /// <param name="fileName">The executable file name.</param>
        /// <param name="args">Arguments for the executable.</param>
        /// <returns>A Task<bool> indicating success (true) or failure (false).</returns>
        private async Task<bool> RunProcessAsync(string fileName, string args)
        {
            var tcs = new TaskCompletionSource<bool>(); // Used to signal completion of the async operation
            var proc = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = fileName,
                    Arguments = args,
                    RedirectStandardOutput = true, // Redirect output
                    RedirectStandardError = true,  // Redirect error
                    UseShellExecute = false,       // Required for redirection
                    CreateNoWindow = true,         // No console window
                },
                EnableRaisingEvents = true // Enable Exited event
            };

            // Event handler for when the process exits
            proc.Exited += (s, e) =>
            {
                // Read all output and error streams before setting the result.
                // This is crucial to prevent deadlocks if the child process's buffers fill up.
                string output = proc.StandardOutput.ReadToEnd();
                string error = proc.StandardError.ReadToEnd();

                if (!string.IsNullOrEmpty(output)) AppendOutput($"[Command Output: {fileName}] {output.Trim()}");
                if (!string.IsNullOrEmpty(error)) AppendOutput($"[Command Error: {fileName}] {error.Trim()}");

                // Set the task result based on the process's exit code
                tcs.TrySetResult(proc.ExitCode == 0);
                proc.Dispose(); // Dispose the process object after it has exited and its streams are read
            };

            try
            {
                proc.Start(); // Start the process
                // No need to call BeginOutputReadLine/BeginErrorReadLine here as we read all on exit.
            }
            catch (Exception ex)
            {
                AppendOutput($"Failed to run command '{fileName} {args}': {ex.Message}");
                tcs.TrySetResult(false); // Signal failure
                proc.Dispose(); // Clean up if start fails
            }
            return await tcs.Task; // Await the completion of the process
        }

        /// <summary>
        /// Overrides the OnFormClosing event to ensure all launched processes are terminated
        /// when the application window is closed.
        /// </summary>
        protected override void OnFormClosing(FormClosingEventArgs e)
        {
            base.OnFormClosing(e);

            // List all process objects that might be running
            Process[] processesToKill = { ngrokProcess, dockerProcess, dotnetProcess, expoProcess };

            foreach (var process in processesToKill)
            {
                SafeKill(process); // Call the safe kill method for each process
            }
        }

        /// <summary>
        /// Safely terminates a given process, handling potential exceptions.
        /// </summary>
        /// <param name="process">The Process object to terminate.</param>
        private void SafeKill(Process process)
        {
            try
            {
                // Check if the process object exists and hasn't already exited
                if (process != null && !process.HasExited)
                {
                    process.Kill(); // Attempt to kill the process and its entire tree
                    process.WaitForExit(2000); // Wait up to 2 seconds for termination
                    process.Dispose(); // Dispose the process object to release system resources
                }
            }
            catch (InvalidOperationException ex)
            {
                // This exception occurs if the process has already exited or is in an invalid state
                AppendOutput($"Warning: Process already exited or invalid state during kill attempt: {ex.Message}");
            }
            catch (Exception ex)
            {
                // Catch any other exceptions during process termination
                AppendOutput($"Error killing process: {ex.Message}");
            }
        }

        /// <summary>
        /// Required method for WinForms designer support.
        /// This method is kept minimal as custom UI setup is done in SetupUI().
        /// </summary>
        private void InitializeComponent()
        {
            this.SuspendLayout();
            //
            // MainForm
            //
            this.ClientSize = new System.Drawing.Size(520, 600); // Default size, will be overridden by SetupUI
            this.Name = "MainForm";
            this.ResumeLayout(false);
        }
    }
}